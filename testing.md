---
layout: default
title: Testing/Debugging Approach
nav_order: 4
---
## Testing and Debugging
### Mechanical Aspect
One of the main challenges we faced in this project was refining the design of the strumming arm. It took several iterations to resolve issues related to mechanical noise, instability, and ensuring the arm had the proper range of motion without interfering with the muting components. We also encountered clearance issues with the pick, as it initially couldn't reach the strings—this required careful adjustments to address positioning and reach. Assembling the servo mounts onto the main mounting plate was also a challenge; it took a while to finalize optimal locations for functionality and support. 
I wish we had more accurately measured where the servo mounts needed to go beforehand, as the mounting plate took a long time to print—making redesigns and reprints time-consuming.  Also, the guitar neck is not exactly flat, but rounded.  This was highlighted when our muting mechanism only really muted the top three strings and less on the bottom strings because they are positioned vertically lower due to the guitar’s design. Additionally, we had to CAD a custom servo mount to ensure the servo stood upright rather than laterally for proper strumming motion. One thing I really wish we had known before starting was the bioacoustic effect of the servo and pick—the vibrations produced a surprisingly loud mechanical noise. Unlike strumming by hand, where your fingers absorb a lot of that vibration and you mainly hear the strings, the strumming arm amplified both the string and mechanical sounds. Understanding that earlier would have informed our material and design choices for quieter operation. These experiences highlighted the importance of planning for mechanical tolerances, acoustic behavior, and clearance early in the design process.

### Electrical/Software Aspect
#### Pulse-Width Modulation using Timer/PWM Module
Sending an accurate PWM signal to the servos was the primary goal of this project. To debug the signal, an oscilloscope was hooked up to the PWM signals on pins PTB18/PTB19, measuring the period, frequency, and width of the pulse. Early on, there were issues in deriving the correct clock period for the TPM module, and consequently the PWM signal. 

In theory, the external oscillator is more reliable as the core clock could potentially be affected by CPU processes. Thus, different base clock frequencies were tested with the TPM module, including the core clock and external 8MHz crystal oscillator. However, using the external oscillator did not produce any signal. The core clock remained the only option. 

With TPM, a prescaler and modulus (MOD) value can be set to define the frequency of the PWM signal. A clock source is chosen, then divided by the prescaler and modulus to produce the frequency. That is, 
$$f_{\text{PWM}}=\frac{f_{\text{clk}}}{\text{Prescaler}\times{\text{MOD} + 1}}$$
The formula can be manipulated to then find a good prescaler and modulus that produces a wide and reasonable range for the CnV value which controls how long the signal remains high-true for per period (1-2ms for servo pulse width). That is, 
$${\text{MOD}} = \frac{f_{\text{clk}}}{\text{Prescaler}\times{f_\text{PWM}}}$$
Initially, TPM had been set up with a 20.97MHz core clock base with a 128 prescaler, producing tick division values that were not necessarily integer and were low resolution with higher prescalers. The image below shows the PWM signal using this clock source.
![image](images/163.84%20on%2020.97Mhz.PNG)

Instead, changing the program to run on a 48MHz core and 64 prescaler was more accurate, resulting in a wider range of precise duty cycles and a modulus value of ~15000 (which falls under the 16-bit modulus integer limit of 65535). However, the core clock was actually running at 47.972352MHz, so the modulus value and CnV values were not necessarily integer divisions and had to be rounded to the nearest integer, reducing its accuracy. Changing the clock frequency involved modifying the clock settings on the board, which is made easy by the clocks interface on the MCUXpresso IDE. More specifically, the FEI (FLL Engaged Internal) core clock was modified to ~48MHz. The MCUXpresso IDE then updates the respective board code files for adjusting the internal clock. With the new board frequency set, more precise PWM signals were achieved for servo motion using the TPM (Timer PWM Module). 

**Signal Analysis and Servo Testing**\
The initial `MOD` value of 14991 as derived from the formula produced an experimental PWM frequency of 50.3 Hz, which is slightly off. Using the oscilloscope, the frequency and pulse width was measured in real-time and the `MOD` value was adjusted via trial and error to achieve near-perfect 50Hz frequency for PWM, as seen in the image below.
![image](images/48MHz%20working!.PNG)

The CnV values were adjusted to correspond to pulse widths between 1-2ms, which provides the full range of motion for a servo. To simplify angle conversions to CnV, the helper function `angle_to_CnV(angle)` takes in an angle value from 0-180 degrees and converts the angle to the appropriate CnV value based on the TPM. That is, since 1-2ms is 1/20 to 1/10 of the 20ms PWM period, this proportion can be applied to the total ticks (`MOD` value) to get the CnV value. That is, ~750-1500 ticks serves as the range of the CnV value for pulse widths between 1-2ms. This function helped with fine-tuning the strumming angles, using a protractor to calibrate and measure the angle limits. It also helped with setting the servo angles that convert to linear actuation with the muting mechanism. 

An Arduino program was designed to test the range of servo angles to linear acutation, using a potentiometer to change the pulse width and consequently the servo angle. The proper servo angle for the muting servo was determined experimentally such that the linearly actuated horizontal mute bar dampens the strings enough to produce the desired palm muting effect. 

#### FSM for Strumming/Muting
An incremental design approach was taken in designing a finite-state machine (FSM) and scheduler that would accomodate both strumming and muting motions. First, the strumming motion was isolated, defining a `StrumState` struct that contained four states: `STRUM_DOWN`, `STRUM_UP`, `MUTE_ON`, and `MUTE_OFF`. Then, a timestamp-based scheduler struct `TimeStep` was defined to schedule certain servo motions at a specified time starting from t=0 ms. All four states were tested and implemented under `state_update()`, and the corresponding motions were tested and confirmed by the changes in pulse width for both PWM channels as observed on the oscilloscope. 

Using a timestamp-based scheduler is not necessarily convenient for modifying the movement patterns, since note lengths (or note values) make more sense to the everyday musician. The `StrumStep` struct in `strummer.h` uses note lengths as the duration for which the program should remain in a certain state. This scheduler uses a timebase of the value of a 16th note (in milliseconds). There are 60000 ms in a minute, so dividing this value by the BPM value and dividing again by 4 results in the duration of a sixteenth note (in ms). Furthemore, integer multipliers of the sixteenth note are used to define the 8th, dotted 8th, and quarter note length value, which is 2x, 3x, and 4x the ms value of a sixteenth note respectively. Most duple-time rhythms can be derived from a combination of these note lengths. 

To test the scheduler, a typical 4/4 strumming pattern was played by hand, then observed and encoded as a sequence of strumming steps. The resultant strumming pattern corresponded to changes in pulse width and servo motion at the expected times. The image below illustrates the classic strumming pattern defined in `patterns.c`.
![Classic](/images/classic.png)

The final design invovles one FSM defined by a `ComboStep[]` array (pattern), unifying strumming and muting motions under one schedule. The schedule contains `ComboStep` steps that control the strumming state (`StrumState`), muting state (`MuteState`), and duration of the step. As defined in `strummer.h`, the `StrumState` enumeration controls the strumming servo position and consists of three possible states: `STRUM_DOWN`, `STRUM_UP`, and `REST`. In the same header file, there are three possible `MuteState` states that control the position of the mute bar: `MUTE_NOCHANGE` (which is the default state if no state is defined at instatiation of `Step`), `MUTE_ON`, and `MUTE_OFF`. 

In the program, a step counter `step_idx` tracks the current step in the pattern. The transitions between steps are scheduled and controlled by PIT interrupts to check whether the time elapsed has met the step duration (see section on **PIT Interrupts and Scheduling** below). Once a step has elapsed its duration, the program moves to the next step in the schedule, updating the mute servo position, then the strumming servo position immediately after. 

Since each step updates both strum and mute states at the same time, strumming and muting have limited independence in this design. That is, muting can only change as the program advances to another strum step. This can be mitigated by maintaining the strum state while changing the mute state, allowing for some independence of the muting servo from the strumming servo. However, utilizing this technique would require adjusting the duration of other steps to maintain the desired strumming pattern. This issue is discussed in **Future Improvements** and compared against having two independent FSMs instead.

**PIT Interrupts and Scheduling**\
The PIT timer is configured to trigger an interrupt every 10ms, serving as the clock for the scheduling of strumming/muting steps. To calculate the correct value of `LDVAL` for the 10ms interval, the formula $\text{LDVAL trigger}=(\text{source frequency }/\text{ interrupt frequency})-1$ is used. Since the PIT runs off of the bus clock (which is half the frequency of the system core clock), and the system core clock is 48 MHz, the effective core clock is 24 MHz. Therefore, the PIT timer is loaded with 479999 ticks to achieve a 10ms interval. 

Insid the interrupt service routine (ISR), the scheduler periodically checks whether the current `ComboStep` is complete by checking `remaining_ms`. If there is still time left (>10 ms), then this variable is decremented by 10ms. Once the duration has been fulfilled, then it advances to the next step in the pattern by calling `strummer_update()` which updates the global states and variables for the step counter and duration. This acts as a real-time task scheduling algorithm, dealing with multiple real-time processes and context switching to other states by a defined schedule without necessarily busy-waiting on the CPU. 

Originally, we mistakenly assumed that the PIT timer was driven by the full system core clock. As a result, strumming patterns played at half speed, as a quarter note at 120 BPM was actually playing at 60 BPM. Dividing the system core clock by 2 and making the corresponding calculations resolved the timing discrepancies and restored the expected tempo.

#### Support for multiple patterns and button toggles
With accurate timing and rhythms established by the PIT scheduler, the next goal involved switching between multiple strumming patterns. Similar to how context switches work with processes, the relevant global variables and states must be reset to adapt to the newly pattern context. To assist with pattern selection, a helper function `strummer_selectPattern(pid, doLoop)` takes in the process id (enumerated by the order of patterns in the patterns array) and whether to loop the strumming pattern. 

A button wired to Port D is used to cycle between the patterns. The Port D interrupt vector is then used to detect a button press and increment the pattern id, selecting the next pattern. Once the max index is reached, the program cycles back to the first pattern id. 

Initially, the button presses were not working due to incorrect wiring of the button to high voltage. Since the port interrupt vector is triggered when connected to ground, the button was wired to have one side connected to the port and the other side connected to ground. This rendered the button to work, but multiple button presses would be registered despite a single button press. A capacitor was wired in parallel to help debounce the button presses, which only alleviated the issue a bit. However, the button was functional and could switch between patterns.

Another button was then used to toggle palm muting. This button updates the global mute state and overrides the previous mute state until the next step in the pattern where the mute state changes. If the pattern doesn't have mute changes, then the user has full control over the muting mechanism. 